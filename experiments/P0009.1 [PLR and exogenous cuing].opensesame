# Generated by OpenSesame 2.8.2~pre4 (Gutsy Gibson)
# Wed Jun  4 11:48:05 2014 (posix)
# <http://www.cogsci.nl/opensesame>

set mouse_backend "psycho"
set subject_parity "even"
set height "768"
set font_family "mono"
set font_italic "no"
set synth_backend "legacy"
set title "P0009.1 [PLR and exogenous cuing]"
set coordinates "relative"
set start "experiment"
set sampler_backend "legacy"
set transparent_variables "no"
set foreground "black"
set font_bold "no"
set description "A template containing a practice and an experimental phase"
set background "gray"
set font_size "18"
set enable_escape "no"
set keyboard_backend "psycho"
set canvas_backend "psycho"
set compensation "0"
set bidi "no"
set subject_nr "0"
set width "1024"
set psychopy_gamma "1"

define notepad CHANGELOG
	__note__
	P0009.1.6
	
	- Fix critical bug in invalidly cued trials
	- Reduce adapt and baseline duration from 1445 to 1245
	- Reduce target duration from 95 to 45
	
	P0009.1.5
	
	- Switch to EyeLink plug-ins
	- Increase stim opacity
	- Add optional practice phase
	- Set block length to 8 (run twice for full experiment of 16 blocks)
	
	P0009.1.4
	
	- Fix keypress after practice
	- Also tilt distractor
	
	P0009.1.2
	
	- Set Boks port to COM4
	- Implement gaze stabilization
	- Add pre-block fixdot_wait
	
	P0009.1.1
	
	- Initial version
	__end__
	set description "A simple notepad to document your experiment. This plug-in does nothing."

define notepad about
	__note__
	# Design
	
	## Fully crossed factors
	
	- soa: 4 levels
	- cue validity: 2 levels
	- brightness of cued side: 2 levels
	
	4 * 2 * 2 = 16 levels
	32 observations per cell
	32 * 16 = 512 trials
	
	# Analyses
	
	## Planned analysis for behavior
	
	A Repeated Measures ANOVA with SOA and cue validity as independent variables and response time as dependent measure. The predicted outcome is a SOA by cue validity interaction, reflecting the transition from facilitation to inhibition. This analysis does not inclde the 2495 SOA.
	
	## Planned analyses for pupil size
	
	### IOR in pupil size
	
	Using the 2495 SOA, map out pupil size as a function of cue-bright and cue-dark. The prediction is that cue-bright will initially produce a relative constriction (matching facilitation in behavior), followed by a relative dilation (matching IOR in behavior).
	
	### Target grabs attention
	
	For each SOA separately, lock the pupil signal on the target appearance and see whether attention shifts towards the side of the target.
	__end__
	set description "A simple notepad to document your experiment. This plug-in does nothing."

define inline_script adapt_and_dc_phase
	___run__
	exp.eyelink.log('start_phase adaptation')
	updateDisplay(dur=adaptDur, stabilize=False)
	exp.eyelink.log('end_phase adaptation')
	# Perform drift correction
	exp.eyelink.drift_correction(fix_triggered=True)
	__end__
	set _prepare ""
	set description "Executes Python code"

define loop block_loop
	set repeat "1"
	set description "A single block of trials"
	set item "trial_sequence"
	set column_order "targetOri;brightSide;cueSide;cueValidity;soa"
	set cycles "32"
	set order "random"
	setcycle 0 targetOri "=choice([60,120])"
	setcycle 0 cueValidity "valid"
	setcycle 0 cueSide "left"
	setcycle 0 soa "45"
	setcycle 0 brightSide "left"
	setcycle 1 targetOri "=choice([60,120])"
	setcycle 1 cueValidity "valid"
	setcycle 1 cueSide "right"
	setcycle 1 soa "45"
	setcycle 1 brightSide "left"
	setcycle 2 targetOri "=choice([60,120])"
	setcycle 2 cueValidity "valid"
	setcycle 2 cueSide "left"
	setcycle 2 soa "45"
	setcycle 2 brightSide "right"
	setcycle 3 targetOri "=choice([60,120])"
	setcycle 3 cueValidity "valid"
	setcycle 3 cueSide "right"
	setcycle 3 soa "45"
	setcycle 3 brightSide "right"
	setcycle 4 targetOri "=choice([60,120])"
	setcycle 4 cueValidity "valid"
	setcycle 4 cueSide "left"
	setcycle 4 soa "945"
	setcycle 4 brightSide "left"
	setcycle 5 targetOri "=choice([60,120])"
	setcycle 5 cueValidity "valid"
	setcycle 5 cueSide "right"
	setcycle 5 soa "945"
	setcycle 5 brightSide "left"
	setcycle 6 targetOri "=choice([60,120])"
	setcycle 6 cueValidity "valid"
	setcycle 6 cueSide "left"
	setcycle 6 soa "945"
	setcycle 6 brightSide "right"
	setcycle 7 targetOri "=choice([60,120])"
	setcycle 7 cueValidity "valid"
	setcycle 7 cueSide "right"
	setcycle 7 soa "945"
	setcycle 7 brightSide "right"
	setcycle 8 targetOri "=choice([60,120])"
	setcycle 8 cueValidity "valid"
	setcycle 8 cueSide "left"
	setcycle 8 soa "2445"
	setcycle 8 brightSide "left"
	setcycle 9 targetOri "=choice([60,120])"
	setcycle 9 cueValidity "valid"
	setcycle 9 cueSide "right"
	setcycle 9 soa "2445"
	setcycle 9 brightSide "left"
	setcycle 10 targetOri "=choice([60,120])"
	setcycle 10 cueValidity "valid"
	setcycle 10 cueSide "left"
	setcycle 10 soa "2445"
	setcycle 10 brightSide "right"
	setcycle 11 targetOri "=choice([60,120])"
	setcycle 11 cueValidity "valid"
	setcycle 11 cueSide "right"
	setcycle 11 soa "2445"
	setcycle 11 brightSide "right"
	setcycle 12 targetOri "=choice([60,120])"
	setcycle 12 cueValidity "valid"
	setcycle 12 cueSide "left"
	setcycle 12 soa "2445"
	setcycle 12 brightSide "left"
	setcycle 13 targetOri "=choice([60,120])"
	setcycle 13 cueValidity "valid"
	setcycle 13 cueSide "right"
	setcycle 13 soa "2445"
	setcycle 13 brightSide "left"
	setcycle 14 targetOri "=choice([60,120])"
	setcycle 14 cueValidity "valid"
	setcycle 14 cueSide "left"
	setcycle 14 soa "2445"
	setcycle 14 brightSide "right"
	setcycle 15 targetOri "=choice([60,120])"
	setcycle 15 cueValidity "valid"
	setcycle 15 cueSide "right"
	setcycle 15 soa "2445"
	setcycle 15 brightSide "right"
	setcycle 16 targetOri "=choice([60,120])"
	setcycle 16 cueValidity "invalid"
	setcycle 16 cueSide "left"
	setcycle 16 soa "45"
	setcycle 16 brightSide "left"
	setcycle 17 targetOri "=choice([60,120])"
	setcycle 17 cueValidity "invalid"
	setcycle 17 cueSide "right"
	setcycle 17 soa "45"
	setcycle 17 brightSide "left"
	setcycle 18 targetOri "=choice([60,120])"
	setcycle 18 cueValidity "invalid"
	setcycle 18 cueSide "left"
	setcycle 18 soa "45"
	setcycle 18 brightSide "right"
	setcycle 19 targetOri "=choice([60,120])"
	setcycle 19 cueValidity "invalid"
	setcycle 19 cueSide "right"
	setcycle 19 soa "45"
	setcycle 19 brightSide "right"
	setcycle 20 targetOri "=choice([60,120])"
	setcycle 20 cueValidity "invalid"
	setcycle 20 cueSide "left"
	setcycle 20 soa "945"
	setcycle 20 brightSide "left"
	setcycle 21 targetOri "=choice([60,120])"
	setcycle 21 cueValidity "invalid"
	setcycle 21 cueSide "right"
	setcycle 21 soa "945"
	setcycle 21 brightSide "left"
	setcycle 22 targetOri "=choice([60,120])"
	setcycle 22 cueValidity "invalid"
	setcycle 22 cueSide "left"
	setcycle 22 soa "945"
	setcycle 22 brightSide "right"
	setcycle 23 targetOri "=choice([60,120])"
	setcycle 23 cueValidity "invalid"
	setcycle 23 cueSide "right"
	setcycle 23 soa "945"
	setcycle 23 brightSide "right"
	setcycle 24 targetOri "=choice([60,120])"
	setcycle 24 cueValidity "invalid"
	setcycle 24 cueSide "left"
	setcycle 24 soa "2445"
	setcycle 24 brightSide "left"
	setcycle 25 targetOri "=choice([60,120])"
	setcycle 25 cueValidity "invalid"
	setcycle 25 cueSide "right"
	setcycle 25 soa "2445"
	setcycle 25 brightSide "left"
	setcycle 26 targetOri "=choice([60,120])"
	setcycle 26 cueValidity "invalid"
	setcycle 26 cueSide "left"
	setcycle 26 soa "2445"
	setcycle 26 brightSide "right"
	setcycle 27 targetOri "=choice([60,120])"
	setcycle 27 cueValidity "invalid"
	setcycle 27 cueSide "right"
	setcycle 27 soa "2445"
	setcycle 27 brightSide "right"
	setcycle 28 targetOri "=choice([60,120])"
	setcycle 28 cueValidity "invalid"
	setcycle 28 cueSide "left"
	setcycle 28 soa "2445"
	setcycle 28 brightSide "left"
	setcycle 29 targetOri "=choice([60,120])"
	setcycle 29 cueValidity "invalid"
	setcycle 29 cueSide "right"
	setcycle 29 soa "2445"
	setcycle 29 brightSide "left"
	setcycle 30 targetOri "=choice([60,120])"
	setcycle 30 cueValidity "invalid"
	setcycle 30 cueSide "left"
	setcycle 30 soa "2445"
	setcycle 30 brightSide "right"
	setcycle 31 targetOri "=choice([60,120])"
	setcycle 31 cueValidity "invalid"
	setcycle 31 cueSide "right"
	setcycle 31 soa "2445"
	setcycle 31 brightSide "right"
	run trial_sequence

define sequence block_sequence
	set flush_keyboard "yes"
	set description "A sequence containing a single block of trials followed by feedback to the participant"
	run fixdot_wait "always"
	run boks_wait "always"
	run reset_feedback "always"
	run block_loop "always"
	run feedback "always"
	run boks_set_noncontinuous "always"
	run boks_wait "always"

define boks boks_init
	set timeout "1"
	set allowed_responses "1;2"
	set description "Initialez the boks"
	set dev "COM4"
	set _dummy "no"

define inline_script boks_set_noncontinuous
	set _run "exp.boks.set_continuous(False)"
	set _prepare ""
	set description "Executes Python code"

define boks boks_wait
	set dev "autodetect"
	set description "Collects input from a boks"
	set timeout "infinite"
	set _dummy "no"

define sketchpad end_of_experiment
	set duration "keypress"
	set description "Displays stimuli"
	draw line 0 0 0 0 penwidth=1 color=black show_if="always"
	draw textline 0 0 "Fin de l'expU+00E9rience" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always" html="yes"

define sketchpad end_of_practice
	set duration "0"
	set description "Displays stimuli"
	draw textline 0 -64 "Fin de l'entrainment" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always" html="yes"
	draw textline 0 64 "Appuyez sur une bouton" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always" html="yes"

define sequence experiment
	set flush_keyboard "yes"
	set description "The main sequence of the experiment"
	run CHANGELOG "always"
	run about "always"
	run experiment_init "always"
	run boks_init "always"
	run eyelink_calibrate "always"
	run form_settings "always"
	run practice_loop "[run_practice] != no"
	run end_of_practice "[run_practice] != no"
	run boks_wait "[run_practice] != no"
	run experimental_loop "always"
	run end_of_experiment "always"

define inline_script experiment_init
	set _run ""
	___prepare__
	exp.set('total_blocks', 8)
	__end__
	set description "Executes Python code"

define loop experimental_loop
	set repeat "[total_blocks]"
	set description "A loop containing one or more experimental blocks"
	set item "block_sequence"
	set column_order "practice"
	set cycles "1"
	set order "random"
	setcycle 0 practice "no"
	run block_sequence

define eyelink_calibrate eyelink_calibrate
	set sacc_vel_thresh "35"
	set cal_beep "yes"
	set description "Calibration/ initialization plugin for the Eyelink series of eye trackers (SR-Research)"
	set sacc_acc_thresh "9500"
	set cal_target_size "16"
	set force_drift_correct "yes"
	set tracker_attached "Yes"

define eyelink_log eyelink_log
	set msg ""
	set throttle "2"
	set description "Message log for the Eyelink series of eye trackers (SR-Research)"
	set auto_log "yes"

define eyelink_start_recording eyelink_start_recording
	set description "Start recording plugin for the Eyelink series of eye trackers (SR-Research)"
	set log_msg "start_trial [count_trial_sequence]"

define eyelink_stop_recording eyelink_stop_recording

define feedback feedback
	set duration "0"
	set reset_variables "yes"
	set description "Provides feedback to the participant"
	draw textline 0 -128 "Fin du bloc [count_block_sequence] du [total_blocks]" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always" html="yes"
	draw textline 0 -64 "Votre temps de rU+00E9ponse moyen U+00E9tait <b>[avg_rt]</b> ms" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always" html="yes"
	draw textline 0 0 "Votre prU+00E9cision U+00E9tait <b>[acc]</b>%" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always" html="yes"
	draw textline 0 64 "Appuyez sur une bouton pour continuer" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always" html="yes"

define sketchpad fixdot_wait
	set duration "0"
	set description "Displays stimuli"
	draw fixdot 0 0 color=black show_if="always"
	draw textline 0 64 "Appuyez sur une bouton pour commencer" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always" html="yes"
	draw textline 0 -64 "RU+00E9gardez le point" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always" html="yes"
	draw textline 0 -320 "practice = [practice]" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always" html="yes"

define form_base form_settings
	set rows "1;1"
	set description "A generic form plug-in"
	set cols "1"
	widget 0 0 1 1 checkbox var="run_practice" text="Run practice block"
	widget 0 1 1 1 button text="Ok"


define loop practice_loop
	set repeat "1"
	set description "A loop containing one or more practice blocks"
	set item "block_sequence"
	set column_order "practice"
	set cycles "1"
	set order "random"
	setcycle 0 practice "yes"
	run block_sequence

define reset_feedback reset_feedback

define inline_script trial_init
	___run__
	print self.time()
	__end__
	___prepare__
	from psychopy.visual import GratingStim
	import numpy as np
	
	def updateDisplay(dur=None, mask=False, timeout=3000, stabilize=True):
		
		"""
		Updates the display for a specified duration.
		
		Keyword arguments:
		dur			--	A duration, None to show only a single frame, or
						'buttonpress' to wait until a button has been pressed.
						(default=None)
		mask		--	Indicates whether the masks should be presented.
						(default=False)
		timeout		--	A timeout value, in case dur == 'buttonpress'.
						(default=3000)
		stabilize	--	Indicates whether the central gradient should be locked
						to horizontal gaze position. (default=True)
		
		Returns:
		A (button, timestamp, correct) tuple in case dur == 'buttonpress', or None if
		duration was something else.
		"""
	
		t1 = self.time()
		while True:		
			if stabilize:
				# Lock the horizontal position of the gradient to the point of gaze,
				# within a +-100px region.
				x, y = exp.eyelink.sample()
				dx = x - self.get('width')/2
				if dx > 100:
					dx = 100
				elif dx < -100:
					dx = -100
				gradientStim.setPos((dx,0))
			backgroundStim.draw()
			gradientStim.draw()
			fixStim.draw()
			if mask:
				maskLeftStim.draw()
				maskRightStim.draw()
			else:
				cueStim.draw()
				distStim.draw()
			win.flip()
			if dur == None:
				return
			elif dur == 'buttonpress':
				l = exp.boks.get_button_state()
				timestamp = self.time()
				if 1 in l:
					button = 1
				elif 2 in l:
					button = 2
				else:
					button = None
				if button != None:
					if int(button) == correct_response:
						correct = 1
					else:
						correct = 0
					return button, timestamp, correct
			elif self.time() - t1 >= dur:
				return
		if dur == 'buttonpress':
			return None, t1+timeout, 0
	
	# Experimental variables
	brightSide = self.get('brightSide')
	cueSide = self.get('cueSide')
	cueValidity = self.get('cueValidity')
	soa = self.get('soa')
	targetOri = self.get('targetOri')
	
	# Other variables
	w = self.get('width')
	h = self.get('height')
	targetDur = 45
	adaptDur = 1245
	baselineDur = 1245
	feedbackDur = 295
	fixSize = 12
	fixColor = 'blue'
	cueSize = 128
	cueFreq = .025
	cueContrast = 1
	cueOpacity = .3
	cueEcc = w/3
	
	# Perform a sanity check on the condition values
	assert(brightSide in ('left', 'right'))
	assert(cueSide in ('left', 'right'))
	assert(cueValidity in ('valid', 'invalid'))
	assert(targetOri in (60, 120))
	assert(soa in (45, 945, 2445))
	
	# Determine the correct response
	if targetOri > 90:
		correct_response = 1
	else:
		correct_response = 2
		
	print 'cr = %s' % correct_response
	
	# Create background texture. The background texture is half bright and half
	# dark. The center gradient is implemented by the gradient texture.
	backgroundTex = np.empty( [1, w], dtype=float )
	backgroundTex[0,:w/2] = -1
	backgroundTex[0,w/2:] = 1
	if brightSide == 'left':
		backgroundTex *= -1
	backgroundStim = GratingStim(win, size=(w,h), tex=backgroundTex, mask=None)
		
	# Create the gradient texture. This is 1/3 rd of the display width, and is
	# anchored to the point of gaze.
	gradientTex = np.empty( [1, w/3], dtype=float )
	gradientTex[0] = np.linspace(-1, 1, w/3)
	if brightSide == 'left':
		gradientTex = gradientTex * -1
	gradientStim = GratingStim(win, size=(w/3,h), tex=gradientTex, mask=None)
	
	# Create fixation dot
	fixStim = GratingStim(win, size=fixSize, tex=None, mask='raisedCos', color= U+005C
		fixColor)
	
	# Create cue and distractor
	if cueSide == brightSide:
		cuePhase = .0
		distPhase = .5
	else:
		cuePhase = .5
		distPhase = .0
	cueStim = GratingStim(win, size=cueSize, sf=cueFreq, contrast=cueContrast, U+005C
		mask='gauss', phase=cuePhase, ori=90, opacity=cueOpacity)
	distStim = GratingStim(win, size=cueSize, sf=cueFreq, contrast=cueContrast, U+005C
		mask='gauss', phase=distPhase, ori=90, opacity=cueOpacity)
	if cueSide == 'left':
		cueStim.setPos((-cueEcc,0))
		distStim.setPos((cueEcc,0))
	else:
		cueStim.setPos((cueEcc,0))
		distStim.setPos((-cueEcc,0))
		
	# Create masks
	maskLeftTex = np.random.random( (cueSize, cueSize) )*2-1
	maskRightTex = np.random.random( (cueSize, cueSize) )*2-1
	maskLeftStim = GratingStim(win, size=cueSize, contrast=cueContrast, U+005C
		mask='gauss', tex=maskLeftTex, pos=(-cueEcc, 0), opacity=cueOpacity)
	maskRightStim = GratingStim(win, size=cueSize, contrast=cueContrast, U+005C
		mask='gauss', tex=maskRightTex, pos=(cueEcc, 0), opacity=cueOpacity)
	
	# Create target. This is simply a reference to the cue or the distractor,
	# depending on whether the cue is valid.
	if cueValidity == 'valid':
		targetStim = cueStim
		oppStim = distStim
	else:
		targetStim = distStim
		oppStim = cueStim
	
	# Set boks to continuous mode with a 1 ms timeout
	exp.boks.set_timeout(1)
	exp.boks.set_continuous(True)
	__end__
	set description "Executes Python code"

define inline_script trial_progression
	___run__
	# Baseline
	exp.eyelink.log('start_phase baseline')
	updateDisplay(dur=baselineDur)
	exp.eyelink.log('end_phase baseline')
	# Show cue
	exp.eyelink.log('start_phase cue')
	for cuePhase in np.linspace(cuePhase, cuePhase+1, 5):
		cueStim.setPhase(cuePhase)	
		updateDisplay()
	exp.eyelink.log('end_phase cue')
	# Delay interval
	exp.eyelink.log('start_phase soa')
	updateDisplay(dur=soa)
	exp.eyelink.log('end_phase soa')
	# Show target
	targetStim.setOri(targetOri)
	oppStim.setOri(0)
	exp.eyelink.log('start_phase target')
	updateDisplay(dur=targetDur)
	t1 = self.time()
	exp.eyelink.log('end_phase target')
	# Show mask
	exp.eyelink.log('start_phase mask')
	button, timestamp, correct = updateDisplay(mask=True, dur='buttonpress')
	if correct:
		fixStim.setColor('green')
	else:
		fixStim.setColor('red')
	rt = timestamp - t1
	exp.eyelink.log('end_phase mask')
	exp.eyelink.log('start_phase feedback')
	updateDisplay(dur=feedbackDur, mask=True)
	self.set_response(button, rt, correct)
	exp.eyelink.log('end_phase feedback')
	__end__
	set _prepare ""
	set description "Executes Python code"

define sequence trial_sequence
	set flush_keyboard "yes"
	set description "A single trial"
	run trial_init "always"
	run adapt_and_dc_phase "always"
	run eyelink_start_recording "always"
	run trial_progression "always"
	run eyelink_log "always"
	run eyelink_stop_recording "always"

